#include "bsp.h"
#if defined (__XGPIO_I2C_H__) && defined (IT6801)
//#include "it6801.h"

u8 IT6801_HDMI_INIT_TABLE[][3] =
{
	{0x0f, 0x03, 0x00},	// Change Bank 0
	{0x10, 0xff, 0x08},		// default:0x00,[3]1:Register reset
	{0x10, 0xff, 0x17},		// default:0x00,[4]1:Auto Video Reset [2]1:Interrupt Reset [1]1:Audio Reset [0]1:Video Reset
	{0x11, 0xff, 0x1f},		// default:0x00,Port0 [4]1:EQ Reset [3]1:CLKD5 Reset [2]1:CDR Reset [1]1:HDCP Reset [0]1:All logic Reset
	{0x18, 0xff, 0x1f},		// default:0x00,Port1 ���
	{0x12, 0xff, 0xf8},		// default:0x00,MHL ���
	{0x10, 0xff, 0x10},		// default:0x00,[4]1:Auto Video Reset
	{0x11, 0xff, 0xa0},		// default:0x00,MHL ���
	{0x18, 0xff, 0xa0},		// default:0x00,Port1 ���
	{0x12, 0xff, 0x00},		// default:0x00,MHL ���
	{0x0f, 0x03, 0x01},	// Change Bank 1
	{0xc0, 0x80, 0x00},		// default:0x80,[7]0:�ֲ�����������Ϣ�����岻��
	{0x0f, 0x03, 0x00},	// Change Bank 0
	{0x17, 0xc0, 0x80},		// default:0xC0,Port0 [7]1:Inverse Port 0 input HCLK
	{0x1e, 0xc0, 0x00},		// default:0xC0,Port1 ���
	{0x0e, 0xff, 0xff},		// default:0xFE,[0]1:Enable RCLK for CEC
	{0x86, 0xff, 0xc9},		/* SW programmable I2C Slave Address of CEC block:0xC8 */
	{0x16, 0x08, 0x08},		// default:0x80,Port0 [3]1: Enable CLKD5 auto power down
	{0x1d, 0x08, 0x08},		// default:0x00,Port1 ���
	{0x2b, 0x07, 0x07},		// default:0x00,Port0 FixTek3D ���(3Dû�л��������������ֲ��������)
	{0x31, 0xff, 0x2c},		// default:0x39
	{0x34, 0xff, 0xe1},		/* SW programmable I2C Slave Address of MHL block:0xE0 */
	{0x35, 0x0c, 0x01},		// default:0x03
	{0x54, 0x0c, 0x09},		// default:0x10,[1:0]01:RCLK Frequency select(������ 0x0c ��ʵû���� 0x09 Ҳû�������ֲ��� [3:2] ������ Reserved)
	{0x6a, 0xff, 0x81},		// default:0x83,Decide which kind of packet on Gene
	{0x74, 0xff, 0xa0},		// default:0x20,[7]1:Enable i2s and SPDIFoutput [5]1:Disable false DE output
	{0x50, 0x1f, 0x12},		// default 0xbf,[4]1:Invert output DCLK and DCLK DELAY 2 Step
	{0x65, 0x0c, 0x58},		// default:0x00,[6]1:embeded sync [5:4]01:YUV422 [3:2]10:12bits
	{0x7a, 0x80, 0x80},		// default:0xD0,[7]1:enable audio B Frame Swap Interupt
	{0x85, 0x02, 0x02},		// default:0x0C,[1]1: gating avmute in video detect module
	{0xc0, 0x03, 0x00},		// default:0x07
	{0x87, 0xff, 0xa9},		/* SW programmable I2C address of EDID RAM:0xA8 */
	{0x71, 0x08, 0x00},		// default:0x08,[3]0:must clear to 0
	{0x37, 0xff, 0x88},		// default:0x80,Port0 [7:0]0x88:must set to 0xA6(�����ֲ�����ĳ�ʼ�������õ�ȴ��0x88)
	{0x4d, 0xff, 0x88},		// default:0x80,Port1 ���
	{0x67, 0x80, 0x00},		// default:0x80,[7]0:disable HW CSCSel
	{0x7a, 0x70, 0x70},		// default:0xD0
	{0x7e, 0x40, 0x00},		// default:0x00
	{0x52, 0x20, 0x20},		// default:0x20,[5]1:for disable Auto video MUTE
	{0x53, 0xc0, 0x32},		// default:0x00,QE16-QE23�� QE28-QE35 ��Ч
	{0x58, 0xff, 0xab},		// Video output driving strength
	{0x59, 0xff, 0xaa},		// Audio output driving strength
	{0x0f, 0x03, 0x01},	// Change bank 1
	{0xbc, 0xff, 0x06},		// �������ڳ�ʼ������ļĴ�����û�����ֲ������λ�ó��֣����岻��
	{0xb5, 0x03, 0x03},		// ͬ��
	{0xb6, 0x07, 0x00},		// ͬ��
	{0xb1, 0xff, 0x20},		// default:0x80,[5]1:software overwrite IPLL
	{0xb2, 0xff, 0x01},		// default:0x04,[1]1:increase filter resistance
	{0x0f, 0x03, 0x00},	// Change bank 0
	{0x25, 0xff, 0x1f},		// Default EQ Value
	{0x3d, 0xff, 0x1f},		// Default EQ Value
	{0x27, 0xff, 0x1f},		// Default EQ Value
	{0x28, 0xff, 0x1f},		// Default EQ Value
	{0x29, 0xff, 0x1f},		// Default EQ Value
	{0x3f, 0xff, 0x1f},		// Default EQ Value
	{0x40, 0xff, 0x1f},		// Default EQ Value
	{0x41, 0xff, 0x1f},		// Default EQ Value
	{0x22, 0xff, 0x00},		// default:0x00
	{0x26, 0xff, 0x00},		// default:0x00
	{0x3a, 0xff, 0x00},		// default:0x00,Port1 ���
	{0x3e, 0xff, 0x00},		// default:0x00,Port1 ���
	{0x20, 0x7f, 0x3f},		// default:0x00,[5:4]11:R_CS ��ʼ�� [3:2]11:G_CS ��ʼ�� [1:0]11:B_CS ��ʼ��
	{0x38, 0x7f, 0x3f},		// default:0x00,Port1 ���
	{0xff, 0xff, 0xff}
};

u8 Edid_Block[256] = {
#if 0// KARAS table
// IT6802 with 640x480p , 720x480p , 1280x720p , 1920x1080p
// EDID ����(Block 0): 0x00 ~ 0x7F
/*----------------------------------------------- Header -----------------------------------------------*/
0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,   				// 0x00 ~ 0x07:EDID��ʼ��־
/*----------------------------------- Vendor / Product Identification ----------------------------------*/
0x26, 0x85, 								      				// 0x08 ~ 0x09:����������
0x02, 0x68, 									  				// 0x0A ~ 0x0B:��Ʒ����
0x01, 0x68, 0x00, 0x00,   						  				// 0x0C ~ 0x0F:��Ʒ���к�
0x00, 0x17, 									  				// 0x10 , 0x11:������(0��Ч),�������(1990��Ϊ0)
/*---------------------------------- EDID Structure Version / Revision ---------------------------------*/
0x01, 0x03,										  				// 0x12 , 0x13:�汾��,�޸ĺ�(v1.3)
/*---------------------------------- Basic Display Parameters / Features -------------------------------*/
0x80, 											  				// 0x14:��Ƶ�źŶ���(bit7=1,�����ź�)
0x73, 0x41,										  				// 0x15 , 0x16:���ˮƽͼ��ߴ磨cm��,���ֱͼ��ߴ磨cm��
0x78,   						  				  				// 0x17:��ʾ�������ԣ�Gamma * 100 - 100����Χ[1,3.55]
0x2A, 											  				// 0x18:��Դ�����׼ DPMS��bit5=1,֧��Off Mode����;bit[4:3]=01,RGB��ɫ��ʾ;bit1=1,�Ƽ��ֱ���ģʽ�����Ƽ��ֱ���Ϊ��һ��������ʱ�� DTD��
/*---------------------------------------- Color Characteristics ---------------------------------------*/
0x7C, 0x11, 0x9E, 0x59, 0x47, 0x9B, 0x27, 0x10, 0x50, 0x54,  	// 0x19 ~ 0x22:���̡����׳��� xy ������Ϣ
/*----------------------------------------- Established Timings ----------------------------------------*/
0x00, 0x00, 0x00,  												// 0x23 ~ 0x25:�ṩ�����̶���һЩ���ʱ��δʹ��ʱ��Ϊ 0x00
/*----------------------------------- Standard Timing Identification -----------------------------------*/
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,		// 0x26 ~ 0x35:�ṩ��� 8 �ֱַ��ʵ�ʶ������һ�飬δʹ��ʱ��Ϊ 0x01
0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
/*---------------------------------- Detailed Timing Descriptions(DTD) ---------------------------------*/
// �Ƽ��ֱ��ʣ����� DTD ռ 18 �ֽڣ����ɼ�¼ 4 �� DTD�������һ���ֹ�ռ 72 �ֽڣ�
0x02, 0x3A,   													// 0x36 , 0x37:ʮ��������ʱ��/10000,�ȴ洢��8λ,����洢��ʱ��Ƶ�ʾ��� 148.5MHz(0x3A02)
0x80, 0x18, 0x71, 												// 0x38 ~ 0x3A:�ֱ��Ӧ H_Active ��8λ��H_Blanking ��8λ��{H_Active ��4λ,H_Blanking ��4λ},����� H_Active Ϊ 1920(0x780) pixels,H_Blanking Ϊ 280(0x118) pixels
0x38, 0x2D, 0x40, 												// 0x3B ~ 0x3D:V ������Ϣ���� H ����,����� V_Active Ϊ 1080(0x438) lines,V_Blanking Ϊ 45(0x2D) lines
0x58, 0x2C,   													// 0x3E , 0x3F:H_Sync Offset ��8λ,H_Sync Pulse Width ��8λ
0x45, 															// 0x40:{V_Sync Offset ��4λ,V_Sync Pulse Width ��4λ}
0x00, 															// 0x41:{H_Sync Offset ��2λ,H_Sync Pulse Width ��2λ,V_Sync Offset ��2λ,V_Sync Pulse Width ��2λ}
0x10, 0x09, 													// 0x42 , 0x43:H_Image Size(mm) ��8λ,V_Image Size(mm) ��8λ
0x00,															// 0x44:{H_Image Size ��4λ��V_Image Size ��4λ}
0x00, 0x00, 													// 0x45 , 0x46:H_Border,V_Border
0x1E,   														// 0x47:bit7=0,������;bit[6:5]=11,������ʾ������;bit[4:3]=11,���ַ����ź�
// �ڶ��� DTD
0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x3E,		// 0x48 ~ 0x59
0x96, 0x00, 0x04, 0x03, 0x00, 0x00, 0x00, 0x18,
// ������ DTD
0x00, 0x00, 0x00, 0xFC, 0x00, 0x49, 0x54, 0x45, 0x36, 0x38,   	// 0x5A ~ 0x6B
0x30, 0x32, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20,
// ���ĸ� DTD
0x00, 0x00, 0x00, 0xFD, 0x00, 0x30, 0x7A, 0x0F, 0x50, 0x10, 	// 0x6C ~ 0x7D
0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
/*-------------------------------------------- Extension Flag ------------------------------------------*/
0x01,    														// 0x7E:������ EDID ��չ��(Block 1)
0xF3,															// 0x7F:����(Block 0)�� Checksum,ʹǰ127�ֽڼ��ϴ��ֽڵ��ܺ�Ϊ0

// EDID ��չ��(Block 1): 0x80 ~ 0xFF
/*---------------------------------------- CEA Extension Header ----------------------------------------*/
0x02, 															// 0x80:CEA Extension Tag���̶�Ϊ 0x02
0x03, 															// 0x81:�޶��ţ�Ŀǰһ��Ϊ 0x03
0x19, 															// 0x82:DTD ��ʼ��ַ�������ʾ�� 0x19(+0x80) ��ʼ���� DTD
0x72,															// 0x83:bit6=1,֧�� basic audio;bit5=1,֧�� YUV444;bit4=1,֧�� YUV422;bit[3:0]=0010,DTD ����Ϊ2
/*------------------------------------------ Vedio Data Block ------------------------------------------*/
0x46, 															// 0x84:bit[7:5]=010,��Ӧ Tag Ϊ Vedio Data Block(0x02);bit[4:0]=00110,���ֽں��� 6 ���ֽ�(SVD)������� VDB
0x90, 0x04, 0x13, 0x01, 0x02, 0x03, 							// 0x85 ~ 0x8A:ÿ���ֽڱ�ʾ֧�ֵ�һ�ֱַ��ʣ�������ֱ��ʵĹ�ϵ�� HDMI ��׼ֱ�Ӷ���
/*------------------------------------------ Audio Data Block ------------------------------------------*/
0x23, 															// 0x8B:bit[7:5]=001,��Ӧ Tag Ϊ Audio Data Block(0x01);bit[4:0]=00011,���ֽں��� 3 ���ֽ�������� ADB
0x09, 0x07, 0x07, 												// 0x8C ~ 0x8E:�����ֽ�Ϊһ�飬�������ֻ��һ��������ص�������Ϣ
																//				byte1(0x09)��bit[6:3]=0001,��Ƶ��ʽΪ Linear PCM;bit[2:0]=001,Max Number of channels Ϊ 001+1=2;
																//				byte2(0x07)��bit[6:0]=0000111,֧��Ƶ�� 48KHz��44.1KHz��32KHz
																//				byte3(0x07)��bit[2:0]=111,֧��λ�� 24bit��20bit��16bit
/*------------------------------------ Speaker Allocation Data Block -----------------------------------*/
0x83,   														// 0x8F:bit[7:5]=100,��Ӧ Tag Ϊ Speaker Allocation Data Block;bit[4:0]=00011,���ֽں��� 3 ���ֽ�������� SADB
0x01, 0x00, 0x00, 												// 0x90 ~ 0x92:�����ֽ�Ϊһ�飬�������ֻ��һ���������λ�õ�������Ϣ
/*-------------------------------------- Vendor Specific Data Block ------------------------------------*/
0x65, 															// 0x93:bit[7:5]=011,��Ӧ Tag Ϊ Vendor Specific Data Block(VSDB);bit[4:0]=00101,���ֽں��� 5 ���ֽ�������� VSDB
0x03, 0x0C, 0x00, 												// 0x94 ~ 0x96:H14b VSDB �̶���ʶ��0x000C03
0x10, 0x00, 													// 0x97 ~ 0x98:CEC�����ַ���˴�Ϊ 1.0.0.0,ͬʱҲ��Ӧ AB(0x97)��CD(0x98) ��ֵ
/*---------------------------------- Detailed Timing Descriptions(DTD) ---------------------------------*/
0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 	// 0x99 ~ 0xAA:����ĵ�һ�� DTD
0x55, 0x00, 0x10, 0x09, 0x00, 0x00, 0x00, 0x1E,
0xD6, 0x09, 0x80, 0xA0, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x60,		// 0xAB ~ 0xBC:����ĵڶ��� DTD
0xA2, 0x00, 0x04, 0x03, 0x00, 0x00, 0x00, 0x18,
0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x3E,		// 0xBC ~ 0xCE:����ĵ����� DTD
0x96, 0x00, 0x10, 0x09, 0x00, 0x00, 0x00, 0x18,
/*----------------------------------------------- Reserved ---------------------------------------------*/
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	0x00, 0x00,		// 0xCF:�Ӹ��ֽڿ�ʼ��֮��û���õ���λ�þ��� 0 ���
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/*-------------------------------------------- Extension Flag ------------------------------------------*/
0x7B  	 														// 0xFF:��չ��(Block 1)�� Checksum,ʹǰ127�ֽڼ��ϴ��ֽڵ��ܺ�Ϊ0
#endif
// KARAS table, maybe has some error, dangerous
//0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x26, 0x85, 0x02, 0x68, 0x01, 0x68, 0x00, 0x00,
//0x00, 0x17, 0x01, 0x03, 0x80, 0x73, 0x41, 0x78, 0x2A, 0x7C, 0x11, 0x9E, 0x59, 0x47, 0x9B, 0x27,
//0x10, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
//0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
//0x45, 0x00, 0x10, 0x09, 0x00, 0x00, 0x00, 0x1E, 0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 0x2D, 0x10,
//0x10, 0x3E, 0x96, 0x00, 0x04, 0x03, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x49,
//0x54, 0x45, 0x36, 0x38, 0x30, 0x32, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
//0x00, 0x30, 0x7A, 0x0F, 0x50, 0x10, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xF3,
//0x02, 0x03, 0x19, 0x72, 0x46, 0x90, 0x04, 0x13, 0x01, 0x02, 0x03, 0x23, 0x09, 0x07, 0x07, 0x83,
//0x01, 0x00, 0x00, 0x65, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E,
//0x20, 0x6E, 0x28, 0x55, 0x00, 0x10, 0x09, 0x00, 0x00, 0x00, 0x1E, 0xD6, 0x09, 0x80, 0xA0, 0x20,
//0xE0, 0x2D, 0x10, 0x10, 0x60, 0xA2, 0x00, 0x04, 0x03, 0x00, 0x00, 0x00, 0x18, 0x8C, 0x0A, 0xD0,
//0x8A, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0x10, 0x09, 0x00, 0x00, 0x00, 0x18, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7B

// example
//0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x11, 0xD2, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x24, 0x14, 0x01, 0x03, 0x80, 0x46, 0x28, 0x78, 0x0A, 0x0D, 0xC9, 0xA0, 0x57, 0x47, 0x98, 0x27,
//0x12, 0x48, 0x4C, 0x20, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
//0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
//0x45, 0x00, 0xDF, 0xA4, 0x21, 0x00, 0x00, 0x1E, 0x01, 0x1D, 0x80, 0x18, 0x71, 0x1C, 0x16, 0x20,
//0x58, 0x2C, 0x25, 0x00, 0xDF, 0xA4, 0x21, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x53,
//0x6F, 0x6E, 0x79, 0x20, 0x41, 0x54, 0x43, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFD,
//0x00, 0x3A, 0x3E, 0x0F, 0x46, 0x0F, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x25,
//0x02, 0x03, 0x3B, 0x71, 0x53, 0x94, 0x13, 0x05, 0x03, 0x04, 0x11, 0x10, 0x1F, 0x20, 0x22, 0x3C,
//0x3E, 0x12, 0x02, 0x01, 0x16, 0x15, 0x07, 0x06, 0x23, 0x0F, 0x7F, 0x07, 0x83, 0x7F, 0x00, 0x00,
//0x7A, 0x03, 0x0C, 0x00, 0x10, 0x00, 0xA8, 0x2D, 0x21, 0xC0, 0x10, 0x01, 0x41, 0x01, 0x12, 0x20,
//0x28, 0x10, 0x66, 0x00, 0x08, 0x10, 0x76, 0x96, 0x90, 0xA0, 0xB0, 0x8C, 0x0A, 0xD0, 0x8A, 0x20,
//0xE0, 0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0xDF, 0xA4, 0x21, 0x00, 0x00, 0x18, 0x8C, 0x0A, 0xD0,
//0x8A, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0x30, 0xA4, 0x21, 0x00, 0x00, 0x18, 0x8C,
//0x0A, 0xA0, 0x14, 0x51, 0xF0, 0x16, 0x00, 0x26, 0x7C, 0x43, 0x00, 0x30, 0xA4, 0x21, 0x00, 0x00,
//0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD2

// it6801 default
//0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x26, 0x85, 0x02, 0x68, 0x00, 0x00, 0x00, 0x00,
//0x01, 0x18, 0x01, 0x03, 0x80, 0x66, 0x39, 0x78, 0x0a, 0xee, 0x91, 0xa3, 0x54, 0x4c, 0x99, 0x26,
//0x0f, 0x50, 0x54, 0xbd, 0xef, 0x80, 0x71, 0x4f, 0x81, 0x00, 0x81, 0x40, 0x81, 0x80, 0x95, 0x00,
//0x95, 0x0f, 0xb3, 0x00, 0xa9, 0x40, 0x02, 0x3a, 0x80, 0x18, 0x71, 0x38, 0x2d, 0x40, 0x58, 0x2c,
//0x45, 0x00, 0xa0, 0x5a, 0x00, 0x00, 0x00, 0x1e, 0x01, 0x1d, 0x00, 0x72, 0x51, 0xd0, 0x1e, 0x20,
//0x6e, 0x28, 0x55, 0x00, 0xa0, 0x5a, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x18,
//0x4b, 0x1a, 0x51, 0x17, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xfc,
//0x00, 0x49, 0x54, 0x45, 0x20, 0x48, 0x44, 0x4d, 0x49, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x01, 0xe7,
//0x02, 0x03, 0x19, 0xf1, 0x44, 0x90, 0x04, 0x05, 0x03, 0x23, 0x09, 0x07, 0x07, 0x83, 0x01, 0x00,
//0x00, 0x67, 0x03, 0x0c, 0x00, 0x10, 0x00, 0x88, 0x2d, 0x02, 0x3a, 0x80, 0x18, 0x71, 0x38, 0x2d,
//0x40, 0x58, 0x2c, 0x45, 0x00, 0xe0, 0x0e, 0x11, 0x00, 0x00, 0x1e, 0x01, 0x1d, 0x00, 0x72, 0x51,
//0xd0, 0x1e, 0x20, 0x6e, 0x28, 0x55, 0x00, 0xa0, 0x5a, 0x00, 0x00, 0x00, 0x1e, 0x01, 0x1d, 0x80,
//0x18, 0x71, 0x1c, 0x16, 0x20, 0x58, 0x2c, 0x25, 0x00, 0xa0, 0x5a, 0x00, 0x00, 0x00, 0x9e, 0x8c,
//0x0a, 0xd0, 0x8a, 0x20, 0xe0, 0x2d, 0x10, 0x10, 0x3e, 0x96, 0x00, 0xa0, 0x5a, 0x00, 0x00, 0x00,
//0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79


// test mine
0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x6B, 0x47, 0x02, 0x68, 0x00, 0x00, 0x00, 0x00,
0x01, 0x18, 0x01, 0x03, 0x80, 0x66, 0x39, 0x78, 0x0A, 0xEE, 0x91, 0xA3, 0x54, 0x4C, 0x99, 0x26,
0x0F, 0x50, 0x54, 0xBD, 0xEF, 0x80, 0x71, 0x4F, 0x81, 0x00, 0x81, 0x40, 0x81, 0x80, 0x95, 0x00,
0x95, 0x0F, 0xB3, 0x00, 0xA9, 0x40, 0x84, 0x21, 0x80, 0xA0, 0x70, 0x00, 0x5F, 0x50, 0x30, 0x20,
0x5A, 0x00, 0xA0, 0x5A, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x18,
0x4B, 0x1A, 0x51, 0x17, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC,
0x00, 0x5A, 0x5A, 0x47, 0x20, 0x48, 0x44, 0x4D, 0x49, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x01, 0xCD,

0x02, 0x03, 0x19, 0xF1, 0x44, 0x90, 0x04, 0x05, 0x03, 0x23, 0x09, 0x07, 0x07, 0x83, 0x01, 0x00,
0x00, 0x67, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x88, 0x2D, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D,
0x40, 0x58, 0x2C, 0x45, 0x00, 0xE0, 0x0E, 0x11, 0x00, 0x00, 0x1E, 0x01, 0x1D, 0x00, 0x72, 0x51,
0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0xA0, 0x5A, 0x00, 0x00, 0x00, 0x1E, 0x01, 0x1D, 0x80,
0x18, 0x71, 0x1C, 0x16, 0x20, 0x58, 0x2C, 0x25, 0x00, 0xA0, 0x5A, 0x00, 0x00, 0x00, 0x9E, 0x8C,
0x0A, 0xD0, 0x8A, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0xA0, 0x5A, 0x00, 0x00, 0x00,
0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79
};

/*
Created by:Advantiv? EEditZ 0.93 by Analog Devices   2023/4/27 17:18:25
Source:
*/
u8 edid[256] = {
		//00                                                                                           0f
		//10                                                                                           1f
	    0x00 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x00 ,0x53 ,0x00 ,0x02 ,0x68 ,0x00 ,0x00 ,0x00 ,0x00 ,  //1920*1080*30
	    0x01 ,0x21 ,0x01 ,0x03 ,0x80 ,0x66 ,0x39 ,0x78 ,0x0A ,0xEE ,0x9D ,0xA2 ,0x54 ,0x4C ,0x98 ,0x26 ,
	    0x0E ,0x4F ,0x54 ,0xBD ,0xEF ,0x80 ,0x71 ,0x4F ,0x81 ,0x00 ,0x81 ,0x40 ,0x81 ,0x80 ,0x95 ,0x00 ,
	    0x95 ,0x0F ,0xB3 ,0x00 ,0xA9 ,0x40 ,0x01 ,0x1D ,0x80 ,0x18 ,0x71 ,0x38 ,0x2D ,0x40 ,0x58 ,0x2C ,
	    0x45 ,0x00 ,0xA0 ,0x5A ,0x00 ,0x00 ,0x00 ,0x1E ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,
	    0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0xFD ,0x0A ,0x14 ,
	    0x2D ,0x14 ,0x2D ,0x50 ,0x00 ,0x0A ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x00 ,0x00 ,0x00 ,0xFC ,
	    0x00 ,0x46 ,0x4B ,0x5F ,0x44 ,0x69 ,0x73 ,0x70 ,0x6C ,0x61 ,0x79 ,0x0A ,0x20 ,0x20 ,0x01 ,0xE5 ,

//	    0x00 ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0xFF ,0x00 ,0x53 ,0x00 ,0x02 ,0x68 ,0x00 ,0x00 ,0x00 ,0x00 ,  //1936*1552*15
//	    0x07 ,0x21 ,0x01 ,0x03 ,0x80 ,0x66 ,0x39 ,0x78 ,0x0A ,0xEE ,0x9D ,0xA2 ,0x54 ,0x4C ,0x98 ,0x26 ,
//	    0x0E ,0x4F ,0x54 ,0xBD ,0xEF ,0x80 ,0x71 ,0x4F ,0x81 ,0x00 ,0x81 ,0x40 ,0x81 ,0x80 ,0x95 ,0x00 ,
//	    0x95 ,0x0F ,0xB3 ,0x00 ,0xA9 ,0x40 ,0xBE ,0x14 ,0x90 ,0x8E ,0x70 ,0x10 ,0x26 ,0x60 ,0x58 ,0x2C ,
//	    0x55 ,0x00 ,0xA0 ,0x5A ,0x00 ,0x00 ,0x00 ,0x1E ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,
//	    0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 ,0xFD ,0x00 ,0x0A ,
//	    0x4B ,0x1A ,0x51 ,0x1E ,0x00 ,0x0A ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x20 ,0x00 ,0x00 ,0x00 ,0xFC ,
//	    0x00 ,0x46 ,0x4B ,0x5F ,0x64 ,0x69 ,0x73 ,0x70 ,0x6C ,0x61 ,0x79 ,0x0A ,0x20 ,0x20 ,0x01 ,0x83 ,

	0x02, 0x03, 0x19, 0xF1, 0x44, 0x90, 0x04, 0x05, 0x03, 0x23, 0x09, 0x07, 0x07, 0x83, 0x01, 0x00,
	0x00, 0x67, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x88, 0x2D, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D,
	0x40, 0x58, 0x2C, 0x45, 0x00, 0xE0, 0x0E, 0x11, 0x00, 0x00, 0x1E, 0x01, 0x1D, 0x00, 0x72, 0x51,
	0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0xA0, 0x5A, 0x00, 0x00, 0x00, 0x1E, 0x01, 0x1D, 0x80,
	0x18, 0x71, 0x1C, 0x16, 0x20, 0x58, 0x2C, 0x25, 0x00, 0xA0, 0x5A, 0x00, 0x00, 0x00, 0x9E, 0x8C,
	0x0A, 0xD0, 0x8A, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0xA0, 0x5A, 0x00, 0x00, 0x00,
	0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79
};

void edid_wr(u8 RegAddr, u8 ucdata)
{
	int ret32;

	ret32 = xgpio_i2c_reg8_write(I2C_NO_0, 0xa8>>1, RegAddr, ucdata, STRETCH_OFF);
}

void hdmirxwr(u8 RegAddr, u8 ucdata)
{
	int ret32;

	ret32 = xgpio_i2c_reg8_write(I2C_NO_0, 0x90>>1, RegAddr, ucdata, STRETCH_OFF);
}

u8 edid_rd(u8 RegAddr)
{
	int ret32;
	u8 ret8=0;
	ret32 = xgpio_i2c_reg8_read(I2C_NO_0, 0xa8>>1, RegAddr, &ret8, STRETCH_OFF);

	return ret8;
}

u8 hdmirxrd(u8 RegAddr)
{
	int ret32;
	u8 ret8=0;
	ret32 = xgpio_i2c_reg8_read(I2C_NO_0, 0x90>>1, RegAddr, &ret8, STRETCH_OFF);

	return ret8;
}

void hdmirxset(u8 RegAddr, u8 mask, u8 ucdata)
{
	u8 ret8;
	u32 ret32;

	ret32 = xgpio_i2c_reg8_read(I2C_NO_0, 0x90>>1, RegAddr, &ret8, STRETCH_OFF);

	ret8=(ret8 & ((~mask) & 0xFF)) + (mask & ucdata);

	ret32 = xgpio_i2c_reg8_write(I2C_NO_0, 0x90>>1, RegAddr, ret8, STRETCH_OFF);
}


void chgbank( int bank )
{
	switch( bank ) {
	case 0 :
		 hdmirxset(0x0F, 0x03, 0x00);
		 break;
	case 1 :
		 hdmirxset(0x0F, 0x03, 0x01);
		 break;
	case 2 :
		 hdmirxset(0x0F, 0x03, 0x02);
		 break;
	case 3:
		 hdmirxset(0x0F, 0x03, 0x03);
		 break;
	default :
		 break;
	}
}

void HPDCtrl(u8 ucEnable)
{
	if(ucEnable == 0)
	{
		if((hdmirxrd(0x0A) & 0x01))
		{
			chgbank(1);
			hdmirxset(0xB0, 0x03, 0x01); //clear port 0 HPD=1 for EDID update
			hdmirxrd(0xB0);
			chgbank(0);
		}
		else
		{
			chgbank(1);
			hdmirxset(0xB0, 0x03, 0x00); //set port 0 Tri-State
			hdmirxrd(0xB0);
			chgbank(0);
		}
	}
	else
	{
		if((hdmirxrd(0x0A) & 0x01))
		{
			chgbank(1);
			hdmirxset(0xB0, 0x03, 0x03); //set port 0 HPD=1
			hdmirxrd(0xB0);
			chgbank(0);
		}
		else
		{
			chgbank(1);
			hdmirxset(0xB0, 0x03, 0x00); //set port 0 Tri-State
			hdmirxrd(0xB0);
			chgbank(0);
		}
	}
}

void hdimrx_write_init(u8 (*init_table)[3])
{
    int i = 0;

    while(init_table[i][0] != 0xff)
    {
    	hdmirxset(init_table[i][0], init_table[i][1], init_table[i][2]);
        i++;
    }
}

void it6801_InterruptHandler(void)
{
	u8 Reg05h;
    u8 Reg06h;
    u8 Reg07h;
    u8 Reg08h;
    u8 Reg09h;
    u8 Reg0Ah;
//	u8 Reg0Bh;
    u8 RegD0h;

	chgbank(0);
	Reg05h = hdmirxrd(0x05);
	Reg06h = hdmirxrd(0x06);
	Reg07h = hdmirxrd(0x07);
	Reg08h = hdmirxrd(0x08);
	Reg09h = hdmirxrd(0x09);
	Reg0Ah = hdmirxrd(0x0A);
//	Reg0Bh = hdmirxrd(0x0B);
	RegD0h = hdmirxrd(0xD0);

	hdmirxwr(0x05, Reg05h);
	hdmirxwr(0x06, Reg06h);
	hdmirxwr(0x07, Reg07h);
	hdmirxwr(0x08, Reg08h);
	hdmirxwr(0x09, Reg09h);
	hdmirxwr(0xD0, RegD0h);

	xil_printf("Reg0A = 0x%02X \r\n", Reg0Ah);
#if 0
	if(Reg05h)
	{
		xil_printf("Reg05 = 0x%02X \r\n", Reg05h);

		if( Reg05h & 0x80 )
		{
			xil_printf("#### Port 0 HDCP Off Detected ###\r\n");
		}
		if(Reg05h & 0x40)
		{
			xil_printf("#### Port 0 ECC Error ####\r\n");
			//TODO: hdmirx_INT_P0_ECC
		}
		if(Reg05h & 0x20)
		{
			xil_printf("#### Port 0 HDMI/DVI Mode change ####\r\n");
			//TODO: if(CLKCheck(0)) ; hdmirx_INT_HDMIMode_Chg(it6802,0);
		}
		if( Reg05h & 0x08 )
		{
			xil_printf("#### Port 0 HDCP Authentication Start ###\r\n");
			//TODO:

			if( Reg0Ah & 0x40)
			{
				//TODO:
			}
		}
		if( Reg05h & 0x10 )
		{
			xil_printf("#### Port 0 HDCP Authentication Done ####\r\n");
			if( Reg0Ah & 0x40 )
			{
				//TODO:
			}
		}
		if( Reg05h & 0x04 )
		{
			xil_printf("#### Port 0 Input Clock Change Detect ####\r\n");
		}
		if( Reg05h & 0x02 )
		{
			xil_printf("#### Port 0 Rx CKOn Detect ####\r\n");
			// TODO:
		}
		if( Reg05h & 0x01 )
		{
			xil_printf("#### Port 0 Power 5V change ####\r\n");
			// TODO: hdmirx_INT_5V_Pwr_Chg
		}
	}
	if(Reg06h)
	{
		// TODO:
	}
	if(Reg07h)
	{
		// TODO:
	}
	if(Reg08h)
	{
		// TODO:
	}
	if(Reg09h)
	{
		// TODO:
	}
	if(RegD0h)
	{
		// TODO:
	}
#endif
}

static void VideoOutputConfigure()
{
	chgbank(0);
	hdmirxwr(0x51, 0x00);
	hdmirxwr(0x65, 0x00);
//	hdmirxwr(0x65, 0x13);
#if 0
	// Color Space Matrix Set
	chgbank(1);
	hdmirxwr(0x70, 0x10);		// YUV601:0x10(0~255)	0x00(16~235)		YUV709:0x10(0~255)	0x00(16~235)
	hdmirxwr(0x71, 0x80);		// YUV601:0x80(0~255)	0x80(16~235)		YUV709:0x80(0~255)	0x80(16~235)
	hdmirxwr(0x72, 0x10);		// YUV601:0x10(0~255)	0x10(16~235)		YUV709:0x10(0~255)	0x10(16~235)
	hdmirxwr(0x73, 0xe4);		// YUV601:0x09(0~255)	0xb2(16~235)		YUV709:0xe4(0~255)	0xb8(16~235)
	hdmirxwr(0x74, 0x04);		// YUV601:0x04(0~255)	0x04(16~235)		YUV709:0x04(0~255)	0x05(16~235)
	hdmirxwr(0x75, 0x77);		// YUV601:0x0e(0~255)	0x65(16~235)		YUV709:0x77(0~255)	0xb4(16~235)
	hdmirxwr(0x76, 0x01);		// YUV601:0x02(0~255)	0x02(16~235)		YUV709:0x01(0~255)	0x01(16~235)
	hdmirxwr(0x77, 0x7f);		// YUV601:0xc9(0~255)	0xe9(16~235)		YUV709:0x7f(0~255)	0x94(16~235)
	hdmirxwr(0x78, 0x00);		// YUV601:0x00(0~255)	0x00(16~235)		YUV709:0x00(0~255)	0x00(16~235)
	hdmirxwr(0x79, 0xd0);		// YUV601:0x0f(0~255)	0x93(16~235)		YUV709:0xd0(0~255)	0x4a(16~235)
	hdmirxwr(0x7a, 0x3c);		// YUV601:0x3d(0~255)	0x3c(16~235)		YUV709:0x3c(0~255)	0x3c(16~235)
	hdmirxwr(0x7b, 0x83);		// YUV601:0x84(0~255)	0x18(16~235)		YUV709:0x83(0~255)	0x17(16~235)
	hdmirxwr(0x7c, 0x03);		// YUV601:0x03(0~255)	0x04(16~235)		YUV709:0x03(0~255)	0x04(16~235)
	hdmirxwr(0x7d, 0xad);		// YUV601:0x6d(0~255)	0x55(16~235)		YUV709:0xad(0~255)	0x9f(16~235)
	hdmirxwr(0x7e, 0x3f);		// YUV601:0x3f(0~255)	0x3f(16~235)		YUV709:0x3f(0~255)	0x3f(16~235)
	hdmirxwr(0x7f, 0x48);		// YUV601:0xab(0~255)	0x49(16~235)		YUV709:0x48(0~255)	0xd9(16~235)
	hdmirxwr(0x80, 0x3d);		// YUV601:0x3d(0~255)	0x3d(16~235)		YUV709:0x3d(0~255)	0x3c(16~235)
	hdmirxwr(0x81, 0x32);		// YUV601:0xd1(0~255)	0x9f(16~235)		YUV709:0x32(0~255)	0x10(16~235)
	hdmirxwr(0x82, 0x3f);		// YUV601:0x3e(0~255)	0x3e(16~235)		YUV709:0x3f(0~255)	0x3f(16~235)
	hdmirxwr(0x83, 0x84);		// YUV601:0x84(0~255)	0x18(16~235)		YUV709:0x84(0~255)	0x17(16~235)
	hdmirxwr(0x84, 0x03);		// YUV601:0x03(0~255)	0x04(16~235)		YUV709:0x03(0~255)	0x04(16~235)
	chgbank(0);
#endif
	// ��λ
	//hdmirxwr(0x64, 0x01);
	//hdmirxwr(0x64, 0x00);

	// QE16-QE23��QE28-QE35 ��Ч
	//hdmirxwr(0x53, 0x32);
//	hdmirxwr(0x53, 0x00);
	hdmirxwr(0x53, 0x30);
}

/*
 * EDID RAM ��ʼ��
 * *pIT6801EDID : ������ʼ�� EDID RAM �������б�
 */
static void EDIDRAMInitial(u8 *pIT6801EDID)
{
	int i;
	u8 send_buf[4] = {0};
	u8 recv_buf[4] = {0};

	hdmirxset(0xc0, 0x01, 0x01);				// HDMI RegC0[1:0]=11 for disable HDMI DDC bus to access EDID RAM


#if 0 //checksum(0x7f,0xff)��������00, ʵ��Ӧ�������
//	set_iic_mode(0, EDID_I2C_ADDR);
//	printf("Read EDID Table:\n");
	for(i = 0; i < 256; i++)
	{
		recv_buf[0] = (u8)i;
//		send_buf[0] = (u8)i;
		//read(fd_i2c, recv_buf, 1);
		recv_buf[0]=edid_rd(recv_buf[0]);
//		send_buf[1]=recv_buf[0];
//		edid_wr(send_buf[0],send_buf[1]);

		printf("%02x ",recv_buf[0]);
		if((i % 16) == 15)
			printf("\r\n");
	}

//	hdmirxset(0xc1, 0xff, 0x91);				// VSDB ��ַ(0x93+4)
//	hdmirxset(0xc2, 0xff, 0x10);				// AB ��ֵ
//	hdmirxset(0xc3, 0xff, 0x00);				// CD ��ֵ
//	hdmirxset(0xc4, 0xff, 0x00);
//	hdmirxset(0xc5, 0xff, 0x00);
#endif
#if 0 //checksum(0x7f,0xff)��������00, ʵ��Ӧ�������
//	set_iic_mode(0, EDID_I2C_ADDR);
//	printf("Read EDID Table:\n");
	for(i = 0; i < 256; i++)
	{
		recv_buf[0] = (u8)i;
		send_buf[0] = (u8)i;
		//read(fd_i2c, recv_buf, 1);
		recv_buf[0]=edid_rd(recv_buf[0]);
		send_buf[1]=recv_buf[0];
		edid_wr(send_buf[0],send_buf[1]);

//		printf("%02x ",recv_buf[0]);
//		if((i % 16) == 15)
//			printf("\r\n");

//		if(i==127)
//		{
//			hdmirxset(0xc4, 0xff, recv_buf[0]);
//		}
//		if(i==255)
//		{
//			hdmirxset(0xc5, 0xff, recv_buf[0]);
//		}
	}

	hdmirxset(0xc1, 0xff, 0x91);				// VSDB ��ַ(0x93+4)
	hdmirxset(0xc2, 0xff, 0x10);				// AB ��ֵ
	hdmirxset(0xc3, 0xff, 0x00);				// CD ��ֵ
	hdmirxset(0xc4, 0xff, 0xe7);
	hdmirxset(0xc5, 0xff, 0x79);
#endif

#if 0  // for KARAS table
//	printf("Set EDID Table:\n");
	for(i = 0; i < 256; i++)
	{
		send_buf[0] = (u8)i;
		send_buf[1] = *(pIT6801EDID+i);
//		write(fd_i2c, send_buf, 2);
		edid_wr(send_buf[0],send_buf[1]);

//		printf("%02x ",send_buf[1]);
//		if((i % 16) == 15)
//			printf("\r\n");
	}

	// printf("Check EDID Table:\n");
	// for(i = 0; i < 256; i++)
	// {
	// 	recv_buf[0] = (u8)i;
	// 	read(fd_i2c, recv_buf, 1);

	// 	printf("%02x ",recv_buf[0]);
	// 	if((i % 16) == 15)
	// 		printf("\r\n");
	// }

//	set_iic_mode(0, HDMI_I2C_ADDR);
	hdmirxset(0xc1, 0xff, 0x93);				// VSDB ��ַ
	hdmirxset(0xc2, 0xff, 0x10);				// AB ��ֵ
	hdmirxset(0xc3, 0xff, 0x00);				// CD ��ֵ
	hdmirxset(0xc4, 0xff, pIT6801EDID[127]);
	hdmirxset(0xc5, 0xff, pIT6801EDID[255]);
#endif

#if 0  // for example
//	printf("Set EDID Table:\n");
	for(i = 0; i < 256; i++)
	{
		send_buf[0] = (u8)i;
		send_buf[1] = *(pIT6801EDID+i);
//		write(fd_i2c, send_buf, 2);
		edid_wr(send_buf[0],send_buf[1]);

//		printf("%02x ",send_buf[1]);
//		if((i % 16) == 15)
//			printf("\r\n");
	}

	// printf("Check EDID Table:\n");
	// for(i = 0; i < 256; i++)
	// {
	// 	recv_buf[0] = (u8)i;
	// 	read(fd_i2c, recv_buf, 1);

	// 	printf("%02x ",recv_buf[0]);
	// 	if((i % 16) == 15)
	// 		printf("\r\n");
	// }

//	set_iic_mode(0, HDMI_I2C_ADDR);
	hdmirxset(0xc1, 0xff, 0xa0);				// VSDB ��ַ(0x93+4)
	hdmirxset(0xc2, 0xff, 0x10);				// AB ��ֵ
	hdmirxset(0xc3, 0xff, 0x00);				// CD ��ֵ
	hdmirxset(0xc4, 0xff, pIT6801EDID[127]);
	hdmirxset(0xc5, 0xff, pIT6801EDID[255]);
#endif

#if 0 // for it6801 internal table
//	printf("Set EDID Table:\n");
	for(i = 0; i < 256; i++)
	{
		send_buf[0] = (u8)i;
		send_buf[1] = *(pIT6801EDID+i);
//		write(fd_i2c, send_buf, 2);
		edid_wr(send_buf[0],send_buf[1]);

//		printf("%02x ",send_buf[1]);
//		if((i % 16) == 15)
//			printf("\r\n");
	}

	// printf("Check EDID Table:\n");
	// for(i = 0; i < 256; i++)
	// {
	// 	recv_buf[0] = (u8)i;
	// 	read(fd_i2c, recv_buf, 1);

	// 	printf("%02x ",recv_buf[0]);
	// 	if((i % 16) == 15)
	// 		printf("\r\n");
	// }

//	set_iic_mode(0, HDMI_I2C_ADDR);
	hdmirxset(0xc1, 0xff, 0x91);				// VSDB ��ַ(0x93+4)
	hdmirxset(0xc2, 0xff, 0x10);				// AB ��ֵ
	hdmirxset(0xc3, 0xff, 0x00);				// CD ��ֵ
	hdmirxset(0xc4, 0xff, pIT6801EDID[127]);
	hdmirxset(0xc5, 0xff, pIT6801EDID[255]);
#endif

#if 1 // test my table
//	printf("Set EDID Table:\n");
	for(i = 0; i < 256; i++)
	{
		send_buf[0] = (u8)i;
		send_buf[1] = *(pIT6801EDID+i);
		edid_wr(send_buf[0],send_buf[1]);

//		printf("%02x ",send_buf[1]);
//		if((i % 16) == 15)
//			printf("\r\n");
	}

	// printf("Check EDID Table:\n");
	// for(i = 0; i < 256; i++)
	// {
	// 	recv_buf[0] = (u8)i;
	// 	read(fd_i2c, recv_buf, 1);

	// 	printf("%02x ",recv_buf[0]);
	// 	if((i % 16) == 15)
	// 		printf("\r\n");
	// }


	hdmirxset(0xc1, 0xff, 0x97);				// VSDB ��ַ(0x93+4)


	hdmirxset(0xc2, 0xff, 0x10);				// AB ��ֵ
	hdmirxset(0xc3, 0xff, 0x00);				// CD ��ֵ
	hdmirxset(0xc4, 0xff, pIT6801EDID[127]);
	hdmirxset(0xc5, 0xff, pIT6801EDID[255]);
#endif

	hdmirxset(0xc0, 0x01, 0x00);				// HDMI RegC0[1:0]=00 for enable HDMI DDC bus to access EDID RAM
}

void it6801_init(void)
{
	u32 ret32;
	u8 ret8=0;
/***********************************************************/
#if 1

	HPDCtrl(0); //��� HPD �ź�V

	chgbank(1);
	hdmirxrd(0xB0); //set port 0 Tri-State
	chgbank(0);
//
	usleep(1000);

	hdimrx_write_init(IT6801_HDMI_INIT_TABLE);

/*
 * IT6801 �ڲ��Դ��� EDID �Ѿ�ֱ�ӽ� 1080p ����Ϊ���Ƽ��ֱ��ʣ���������Ҫ�����ֱ��ʹ��
 */
	hdmirxwr(0xc0, 0x44); // ѡ���ڲ� EDID

//	EDIDRAMInitial(Edid_Block);	// EDID RAM ��ʼ��
	EDIDRAMInitial(edid);	// EDID RAM ��ʼ��

	usleep(1000*100);
	hdmirxset(0x51, 0x01, 0x00); //���� port 0 Ϊ main port


	VideoOutputConfigure();

	HPDCtrl(1); //���� HPD �ź�V

#endif
}

#endif // __XGPIO_I2C_H__ && IT6801

